{"/home/travis/build/npmtest/node-npmtest-grunt-usemin/test.js":"/* istanbul instrument in package npmtest_grunt_usemin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/lib.npmtest_grunt_usemin.js":"/* istanbul instrument in package npmtest_grunt_usemin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_grunt_usemin = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_grunt_usemin = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-grunt-usemin && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_grunt_usemin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_grunt_usemin\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_grunt_usemin.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_grunt_usemin.rollup.js'] =\n            local.assetsDict['/assets.npmtest_grunt_usemin.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_grunt_usemin.__dirname +\n                    '/lib.npmtest_grunt_usemin.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/lib/configwriter.js":"'use strict';\nvar path = require('path');\nvar File = require('./file');\nvar _ = require('lodash');\n\nvar deepMerge = function (origCfg, cfg) {\n  var outCfg = origCfg;\n\n  // If the newly generated part is already in the config file\n  // with the same destination update only the source part, instead of add the whole block again.\n  // This way the same targets wont be regenerated multiple times if usemin is called\n  // multiple times which can happen with grunt-watcher spawn:false mode (#307)\n\n  if (origCfg.files && cfg.files) {\n    var done = false;\n    for (var i = 0; i < origCfg.files.length; i++) {\n      if (outCfg.files[i].dest === cfg.files[0].dest) {\n        outCfg.files[i].src = cfg.files[0].src;\n        done = true;\n      }\n    }\n    if (!done) {\n      outCfg.files = _.union(origCfg.files, cfg.files);\n    }\n  } else if (cfg.files) {\n    outCfg.files = cfg.files;\n  }\n\n  return outCfg;\n};\n\n//\n// Create a config writer for the furnished flow.\n// The created config will:\n//  - use staging directory for intermediate created files\n//  - output the final files under the dest directory.\n//\n// flow is an array of strings that contains name of each steps, in order.\n// Each of the steps is corresponding to a processor that will be used on the files\n// enclosed in blocks (for example, concat, uglify).\n// Note that a corresponding file implementing a dedicated writer needs to be present\n// under the same name, in config directory.\n//\n// Additional configurations post-processors can be also given.\n// These post-processors are updating additional configuration based on the output of the flow.\n//\n// For example:\n//\n//   var w = new ConfigWriter( ['concat', 'uglify'], [], {input: 'app', staging: '.tmp', dest: 'dist'});\n//\n//   We'll:\n//     - have files config/concat.js and config/uglify.js implementing each config writer\n//     - Use .tmp for the output of concat and input of uglify\n//     - Deliver for each block the requested file under dist directory\n//\n//\nvar ConfigWriter = module.exports = function (flow, dirs) {\n  var self = this;\n  this.flow = flow;\n  // FIXME: check dest and staging are furnished\n  this.root = dirs.root;\n  this.dest = dirs.dest;\n  this.staging = dirs.staging;\n  this.steps = {};\n  this.postprocessors = [];\n  this.destinations = {};\n\n  // We need to create all the needed config writers, given them their output directory\n  // E.g, if we do have the flow concat | uglify, the output dir will be .tmp/concat and dist\n  // if the flow is concat | uglify | foo, the dirs will be .tmp/concat, .tmp/uglify, dist\n  flow.blockTypes().forEach(function (blockType) {\n    self.steps[blockType] = [];\n    self.postprocessors[blockType] = [];\n\n    flow.steps(blockType).forEach(function (item) {\n      var step;\n      if (_.isString(item)) {\n        step = require(path.join(__dirname, 'config', item));\n      } else {\n        // Assume this is a user furnished step\n        // FIXME: Add checks on object attributes\n        step = item;\n      }\n      self.steps[blockType].push(step);\n    });\n\n    flow.post(blockType).forEach(function (item) {\n      var pp;\n      if (_.isString(item)) {\n        pp = require(path.join(__dirname, 'config', item));\n      } else {\n        // Assume this is a user furnished post-processor\n        // FIXME: Add checks on object attributes\n        pp = item;\n      }\n      self.postprocessors[blockType].push(pp);\n    });\n\n  });\n\n  // postprocessorsList.forEach(function (item) {\n  //   var pp;\n  //   if (_.isString(item)) {\n  //     pp = require(path.join(__dirname, 'config', item));\n  //   } else {\n  //     // Assume this is a user furnished post-processor\n  //     // FIXME: Add checks on object attributes\n  //     pp = item;\n  //   }\n  //   self.postprocessors.push(pp);\n  // });\n};\n\nConfigWriter.prototype.stepWriters = function (blockType) {\n  var writers;\n\n  if (blockType) {\n    writers = this.steps[blockType] || [];\n  } else {\n    writers = _.uniq(_.flatten(_.values(this.steps), true)); // Only 1 level\n  }\n  return writers;\n};\n\nConfigWriter.prototype.postWriters = function (blockType) {\n  return this.postprocessors[blockType] || [];\n};\n\n\n//\n// Iterate over steps for the furnished block type.\n// The callback is called with the following parameters:\n//  - step : the step by itself\n//  - last : boolean indicating if this is the last writer of the pipe\n//\nConfigWriter.prototype.forEachStep = function (blockType, cb) {\n  var writersCount = this.stepWriters(blockType).length;\n  this.stepWriters(blockType).forEach(function (step, index) {\n    cb(step, index === writersCount - 1);\n  });\n};\n\n//\n// Process the blocks of the furnished file. This means:\n//  + have each block go through the flow of processors\n//  + update dependent configuration based on the output of the flow\n// and update the furnished config\n//\n// If file is a string it will be considered as the filepath,\n// otherwise it should be an object that conforms to File (in lib/file.js) API\n//\nConfigWriter.prototype.process = function (file, config) {\n  var self = this;\n  var lfile = file;\n\n  config = config || {};\n\n  if (_.isString(file)) {\n    lfile = new File(file);\n  }\n\n  lfile.blocks.forEach(function (block) {\n    // FIXME: support several searchPath...\n    var context = {\n      inDir: self.root || lfile.searchPath[0],\n      inFiles: block.src,\n      outFiles: []\n    };\n\n    if (block.searchPath.length > 0) {\n      // FIXME: we must use all the furnished directories\n      context.inDir = block.searchPath[0];\n    }\n\n    self.forEachStep(block.type, function (writer, last) {\n      var blockConfig;\n      var fileSet;\n      var dest;\n\n      // If this is the last writer of the pipe, we need to output\n      // in the destination directory\n      context.outDir = last ? self.dest : path.join(self.staging, writer.name);\n      context.last = last;\n      config[writer.name] = config[writer.name] || {};\n      config[writer.name].generated = config[writer.name].generated || {};\n      context.options = config[writer.name];\n      // config[writer.name].generated = _.extend(config[writer.name].generated, writer.createConfig(context, block));\n      blockConfig = writer.createConfig(context, block);\n      if (blockConfig.files) {\n        fileSet = blockConfig.files;\n        blockConfig.files = [];\n        fileSet.forEach(function (filesInfo) {\n          dest = filesInfo.dest;\n          if (!self.destinations[dest]) {\n            self.destinations[dest] = filesInfo;\n            blockConfig.files.push(filesInfo);\n          } else if (!_.isEqual(self.destinations[dest], filesInfo)) {\n            throw new Error('Different sources attempting to write to the same destination:\\n ' + JSON.stringify(self.destinations[dest], null, '    ') + '\\n  ' + JSON.stringify(blockConfig, null, '    '));\n          }\n        });\n\n        if (blockConfig.files.length) {\n          config[writer.name].generated = deepMerge(config[writer.name].generated, blockConfig);\n        }\n      } else {\n        config[writer.name].generated = deepMerge(config[writer.name].generated, blockConfig);\n      }\n      context.inDir = context.outDir;\n      context.inFiles = context.outFiles;\n      context.outFiles = [];\n      context.options = null;\n    });\n\n    context.inDir = lfile.searchPath[0];\n    if (block.searchPath.length > 0) {\n      context.inDir = block.searchPath[0];\n    }\n    context.inFiles = block.src;\n\n    if (self.postprocessors.hasOwnProperty(block.type)) {\n      self.postprocessors[block.type].forEach(function (pp) {\n        config[pp.name] = config[pp.name] || {};\n        context.options = config[pp.name];\n        config[pp.name] = _.extend(config[pp.name], pp.createConfig(context, block));\n        context.options = null;\n      });\n    }\n  });\n\n  return config;\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/lib/file.js":"'use strict';\nvar path = require('path');\nvar fs = require('fs');\n\n// File is responsible to gather all information related to a given parsed file, as:\n//  - its dir and name\n//  - its content\n//  - the search paths where referenced resource will be looked at\n//  - the list of parsed blocks\n//\n\n//\n// Returns an array object of all the directives for the given html.\n// Each item of the array has the following form:\n//\n//\n//     {\n//       type: 'css',\n//       dest: 'css/site.css',\n//       src: [\n//         'css/normalize.css',\n//         'css/main.css'\n//       ],\n//       raw: [\n//         '    <!-- build:css css/site.css -->',\n//         '    <link rel=\"stylesheet\" href=\"css/normalize.css\">',\n//         '    <link rel=\"stylesheet\" href=\"css/main.css\">',\n//         '    <!-- endbuild -->'\n//       ]\n//     }\n//\n// Note also that dest is expressed relatively from the root. I.e., if the block starts with:\n//    <!-- build:css /foo/css/site.css -->\n// then dest will equal foo/css/site.css (note missing trailing /)\n//\nvar getBlocks = function (content) {\n  // start build pattern: will match\n  //  * <!-- build:[target] output -->\n  //  * <!-- build:[target](alternate search path) output -->\n  // The following matching param are set when there's a match\n  //   * 0 : the whole matched expression\n  //   * 1 : the target (i.e. type)\n  //   * 2 : the alternate search path\n  //   * 3 : the output\n  //\n  var regbuild = /<!--\\s*build:(\\w+)(?:\\(([^\\)]+)\\))?\\s*([^\\s]+)\\s*-->/;\n  // end build pattern -- <!-- endbuild -->\n  var regend = /<!--\\s*endbuild\\s*-->/;\n\n  var lines = content.replace(/\\r\\n/g, '\\n').split(/\\n/);\n  var block = false;\n  var sections = [];\n  var last;\n\n  lines.forEach(function (l) {\n    var indent = (l.match(/^\\s*/) || [])[0];\n    var build = l.match(regbuild);\n    var endbuild = regend.test(l);\n    var startFromRoot = false;\n\n    // discard empty lines\n    if (build) {\n      block = true;\n      // Handle absolute path (i.e. with respect to the server root)\n      // if (build[3][0] === '/') {\n      //   startFromRoot = true;\n      //   build[3] = build[3].substr(1);\n      // }\n      last = {\n        type: build[1],\n        dest: build[3],\n        startFromRoot: startFromRoot,\n        indent: indent,\n        searchPath: [],\n        src: [],\n        raw: []\n      };\n\n      if (build[2]) {\n        // Alternate search path\n        last.searchPath.push(build[2]);\n      }\n    }\n    // Check IE conditionals\n    var isConditionalStart = l.match(/(<!--\\[if.*\\]>)(<!-->)?( -->)?/g);\n    var isConditionalEnd = l.match(/(<!--\\s?)?(<!\\[endif\\]-->)/g);\n    if (block && isConditionalStart) {\n      last.conditionalStart = isConditionalStart;\n    }\n    if (block && isConditionalEnd) {\n      last.conditionalEnd = isConditionalEnd;\n    }\n\n    // switch back block flag when endbuild\n    if (block && endbuild) {\n      last.raw.push(l);\n      sections.push(last);\n      block = false;\n    }\n\n    if (block && last) {\n      var asset = l.match(/(href|src)=[\"']([^'\"]+)[\"']/);\n      if (asset && asset[2]) {\n        last.src.push(asset[2]);\n\n        var media = l.match(/media=['\"]([^'\"]+)['\"]/);\n        // FIXME: media attribute should be present for all members of the block *and* having the same value\n        if (media) {\n          last.media = media[1];\n        }\n\n        // preserve defer attribute\n        var defer = / defer/.test(l);\n        if (defer && last.defer === false || last.defer && !defer) {\n          throw new Error('Error: You are not supposed to mix deferred and non-deferred scripts in one block.');\n        } else if (defer) {\n          last.defer = true;\n        } else {\n          last.defer = false;\n        }\n\n        // preserve async attribute\n        var async = / async/.test(l);\n        if (async && last.async === false || last.async && !async) {\n          throw new Error('Error: You are not supposed to mix asynced and non-asynced scripts in one block.');\n        } else if (async) {\n          last.async = true;\n        } else {\n          last.async = false;\n        }\n\n        // RequireJS uses a data-main attribute on the script tag to tell it\n        // to load up the main entry point of the amp app\n        //\n        // If we find one, we must record the name of the main entry point,\n        // as well the name of the destination file, and treat\n        // the furnished requirejs as an asset (src)\n        var main = l.match(/data-main=['\"]([^'\"]+)['\"]/);\n        if (main) {\n          throw new Error('require.js blocks are no more supported.');\n        }\n      }\n      last.raw.push(l);\n    }\n  });\n\n  return sections;\n};\n\n\nmodule.exports = function (filepath) {\n  this.dir = path.dirname(filepath);\n  this.name = path.basename(filepath);\n  // By default referenced content will be looked at relative to the location\n  // of the file\n  this.searchPath = [this.dir];\n  this.content = fs.readFileSync(filepath).toString();\n\n  // Let's parse !!!\n  this.blocks = getBlocks(this.content);\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/lib/fileprocessor.js":"'use strict';\nvar debug = require('debug')('fileprocessor');\nvar File = require('./file');\nvar _ = require('lodash');\nvar chalk = require('chalk');\n\nvar _defaultPatterns = {\n  html: [\n    [\n      /<script.+src=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML to reference our concat/min/revved script files'\n    ],\n    [\n      /<link[^\\>]+href=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new css filenames'\n    ],\n    [\n      /<img[^\\>]*[^\\>\\S]+src=['\"]([^'\"\\)#]+)(#.+)?[\"']/gm,\n      'Update the HTML with the new img filenames'\n    ],\n    [\n      /<video[^\\>]+src=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new video filenames'\n    ],\n    [\n      /<video[^\\>]+poster=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new poster filenames'\n    ],\n    [\n      /<source[^\\>]+src=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new source filenames'\n    ],\n    [\n      /data-main\\s*=['\"]([^\"']+)['\"]/gm,\n      'Update the HTML with data-main tags',\n      function (m) {\n        return m.match(/\\.js$/) ? m : m + '.js';\n      },\n      function (m) {\n        return m.replace('.js', '');\n      }\n    ],\n    [\n      /data-(?!main).[^=]+=['\"]([^'\"]+)['\"]/gm,\n      'Update the HTML with data-* tags'\n    ],\n    [\n      /url\\(\\s*['\"]?([^\"'\\)]+)[\"']?\\s*\\)/gm,\n      'Update the HTML with background imgs, case there is some inline style'\n    ],\n    [\n      /<a[^\\>]+href=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with anchors images'\n    ],\n    [\n      /<input[^\\>]+src=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with reference in input'\n    ],\n    [\n      /<meta[^\\>]+content=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new img filenames in meta tags'\n    ],\n    [\n      /<object[^\\>]+data=['\"]([^\"']+)[\"']/gm,\n      'Update the HTML with the new object filenames'\n    ],\n    [\n      /<image[^\\>]*[^\\>\\S]+xlink:href=['\"]([^\"'#]+)(#.+)?[\"']/gm,\n      'Update the HTML with the new image filenames for svg xlink:href links'\n    ],\n    [\n      /<image[^\\>]*[^\\>\\S]+src=['\"]([^'\"\\)#]+)(#.+)?[\"']/gm,\n      'Update the HTML with the new image filenames for src links'\n    ],\n    [\n      /<(?:img|source)[^\\>]*[^\\>\\S]+srcset=['\"]([^\"'\\s]+)\\s*?(?:\\s\\d*?[w])?(?:\\s\\d*?[x])?\\s*?[\"']/gm,\n      'Update the HTML with the new image filenames for srcset links'\n    ],\n    [\n      /<(?:use|image)[^\\>]*[^\\>\\S]+xlink:href=['\"]([^'\"\\)#]+)(#.+)?[\"']/gm,\n      'Update the HTML within the <use> tag when referencing an external url with svg sprites as in svg4everybody'\n    ]\n  ],\n  css: [\n    [\n      /(?:src=|url\\(\\s*)['\"]?([^'\"\\)(\\?|#)]+)['\"]?\\s*\\)?/gm,\n      'Update the CSS to reference our revved images'\n    ]\n  ],\n  json: [\n    [\n      /:\\s*['\"]([^\"']+)[\"']/gm,\n      'Update the json value to reference our revved url'\n    ]\n  ],\n  svg: [\n    [\n      /<image[^\\>]*[^\\>\\S]+xlink:href=['\"]([^\"'#]+)(#.+)?[\"']/gm,\n      'Update the SVG with the new image filenames for svg xlink:href links'\n    ]\n  ]\n};\n\n//\n// Default block replacement functions, for css and js types\n//\nvar defaultBlockReplacements = {\n  css: function (block) {\n    var media = block.media ? ' media=\"' + block.media + '\"' : '';\n    return '<link rel=\"stylesheet\" href=\"' + block.dest + '\"' + media + '>';\n  },\n  js: function (block) {\n    var defer = block.defer ? 'defer ' : '';\n    var async = block.async ? 'async ' : '';\n    return '<script ' + defer + async + 'src=\"' + block.dest + '\"><\\/script>';\n  }\n};\n\nvar FileProcessor = module.exports = function (type, patterns, finder, logcb, blockReplacements) {\n  if (!type) {\n    throw new Error('No type given');\n  }\n\n  if (!_.isArray(patterns)) {\n    throw new Error('Patterns must be an array');\n  }\n\n  this.patterns = _defaultPatterns[type] || [];\n\n  if (patterns.length) {\n    this.patterns = this.patterns.concat(patterns);\n  }\n\n  this.log = logcb || function () {};\n\n  if (!finder) {\n    throw new Error('Missing parameter: finder');\n  }\n  this.finder = finder;\n\n\n  this.blockReplacements = _.assign({}, defaultBlockReplacements);\n  if (blockReplacements && _.keys(blockReplacements).length > 0) {\n    _.assign(this.blockReplacements, blockReplacements);\n  }\n\n};\n\n//\n// Replace blocks by their target\n//\nFileProcessor.prototype.replaceBlocks = function replaceBlocks(file) {\n  var result = file.content;\n  var linefeed = /\\r\\n/g.test(result) ? '\\r\\n' : '\\n';\n  file.blocks.forEach(function (block) {\n    var blockLine = block.raw.join(linefeed);\n    result = result.replace(blockLine, this.replaceWith(block));\n  }, this);\n  return result;\n};\n\n\nFileProcessor.prototype.replaceWith = function replaceWith(block) {\n  var result;\n  var conditionalStart = block.conditionalStart ? block.conditionalStart + '\\n' + block.indent : '';\n  var conditionalEnd = block.conditionalEnd ? '\\n' + block.indent + block.conditionalEnd : '';\n  if (typeof block.src === 'undefined' || block.src === null || block.src.length === 0) {\n    // there are no css or js files in the block, remove it completely\n    result = '';\n  } else if (_.contains(_.keys(this.blockReplacements), block.type)) {\n    result = block.indent + conditionalStart + this.blockReplacements[block.type](block) + conditionalEnd;\n  } else {\n    result = '';\n  }\n  return result;\n};\n\n//\n// Replace reference to scripts, css, images, ... in +lines+ with their revved version\n// If +lines+ is not furnished, use instead the cached version (i.e. stored at constructor time)\n//\nFileProcessor.prototype.replaceWithRevved = function replaceWithRevved(lines, assetSearchPath) {\n  // Replace script sources\n  var self = this;\n  var content = lines;\n  var regexps = this.patterns;\n  var identity = function (m) {\n    return m;\n  };\n\n  // Replace reference to script with the actual name of the revved script\n  regexps.forEach(function (rxl) {\n    var filterIn = rxl[2] || identity;\n    var filterOut = rxl[3] || identity;\n\n    self.log(rxl[1]);\n    content = content.replace(rxl[0], function (match, src) {\n      // Consider reference from site root\n      var srcFile = filterIn(src);\n\n      debug('Let\\'s replace ' + src);\n\n      debug('Looking for revved version of ' + srcFile + ' in ', assetSearchPath);\n\n      var file = self.finder.find(srcFile, assetSearchPath);\n\n      debug('Found file \\'%s\\'', file);\n\n      if (src === '/') {\n        return match;\n      }\n\n      var res = match.replace(src, filterOut(file));\n      if (srcFile !== file) {\n        self.log(chalk.cyan(src) + ' changed to ' + chalk.cyan(file));\n      }\n      return res;\n    });\n  });\n\n  return content;\n};\n\n\nFileProcessor.prototype.process = function (filename, assetSearchPath) {\n  debug('processing file %s', filename, assetSearchPath);\n\n  if (_.isString(filename)) {\n    this.file = new File(filename);\n  } else {\n    // filename is an object and should conform to lib/file.js API\n    this.file = filename;\n  }\n\n  if (assetSearchPath && assetSearchPath.length !== 0) {\n    this.file.searchPath = assetSearchPath;\n  }\n\n  var content = this.replaceWithRevved(this.replaceBlocks(this.file), this.file.searchPath);\n\n  return content;\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/lib/flow.js":"'use strict';\nvar _ = require('lodash');\n\n//\n// Encapsulate definition of a flow's steps, per block types\n//\n// The flowConfig parameter has the following form:\n//\n//  {\n//    steps: {\n//      js: ['bar', 'baz'],\n//      css: ['foo']\n//     }\n//   }\n//\nvar Flow = module.exports = function (flowConfig) {\n  this.setSteps(flowConfig.steps);\n  this.setPost(flowConfig.post);\n};\n\nFlow.formatStepName = function (step) {\n  if (typeof step === 'string') {\n    return /uglify/.test(step) ? 'uglify' : step;\n  }\n\n  step.name = /uglify/.test(step.name) ? 'uglify' : step.name;\n\n  return step;\n};\n\nFlow.formatSteps = function (steps) {\n  var formattedSteps = {};\n  _.forIn(steps, function (config, type) {\n    formattedSteps[type] = config.map(Flow.formatStepName);\n  });\n\n  return formattedSteps;\n};\n\n//\n// Returns the steps for the furnished block type\n//\nFlow.prototype.steps = function (blockType) {\n  return this._steps[blockType] || [];\n};\n\n//\n// Set the steps for the flow\n//\nFlow.prototype.setSteps = function (steps) {\n  this._steps = Flow.formatSteps(steps) || {};\n};\n\n//\n// Returns the postprocessors for the furnished block type\n//\nFlow.prototype.post = function (blockType) {\n  return this._post[blockType] || [];\n};\n\n//\n// Set the post for the flow\n//\nFlow.prototype.setPost = function (post) {\n  this._post = Flow.formatSteps(post) || {};\n};\n\n\n//\n// Returns all referenced block types (i.e. the union of the block types from\n// steps and postprocessors)\n//\nFlow.prototype.blockTypes = function () {\n  return _.union(_.keys(this._steps), _.keys(this._post));\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/lib/revvedfinder.js":"'use strict';\nvar debug = require('debug')('revvedfinder');\nvar path = require('path');\nvar _ = require('lodash');\n\n// Allow to find, on disk, the revved version of a furnished file\n//\n// +locator+ : this is either:\n//    - a hash mapping files with their revved versions\n//    - a function that will return a list of file matching a given pattern (for example grunt.file.expand)\n//\nvar RevvedFinder = module.exports = function (locator) {\n  if (_.isFunction(locator)) {\n    debug('using function locator');\n    this.expandfn = locator;\n  } else {\n    debug('using file locator %s', locator);\n    this.mapping = locator;\n  }\n};\n\nvar regexpQuote = function (str) {\n  return (str + '').replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, '\\\\$1');\n};\n\nRevvedFinder.prototype.getCandidatesFromMapping = function (file, searchPaths) {\n  var dirname = path.dirname(file);\n  var filepath = dirname === '.' ? '' : dirname + '/';\n  var candidates = [];\n  var self = this;\n\n  searchPaths.forEach(function (sp) {\n    var key = path.normalize(path.join(sp, file));\n    debug('Looking at mapping for %s (from %s/%s)', key, sp, file);\n\n    if (self.mapping[key]) {\n      // We need to transform the actual file to a form that matches the one we received\n      // For example if we received file 'foo/images/test.png' with searchPaths == ['dist'],\n      // and found in mapping that 'dist/foo/images/test.png' has been renamed\n      // 'dist/foo/images/test.1234.png' by grunt-rev, then we need to return\n      // 'foo/images/test.1234.png'\n      var cfile = path.basename(self.mapping[key]);\n      candidates.push(filepath + cfile);\n      debug('Found a candidate: %s/%s', dirname, cfile);\n    }\n  });\n\n  return candidates;\n};\n\nRevvedFinder.prototype.getCandidatesFromFS = function (file, searchPaths) {\n  var extname = path.extname(file);\n  var basename = path.basename(file, extname);\n  var dirname = path.dirname(file);\n  var hex = '[0-9a-fA-F]+';\n  var regPrefix = '(' + hex + '\\\\.' + regexpQuote(basename) + ')';\n  var regSuffix = '(' + regexpQuote(basename) + '\\\\.' + hex + regexpQuote(extname) + ')';\n  var revvedRx = new RegExp(regPrefix + '|' + regSuffix);\n  var candidates = [];\n  var self = this;\n\n  searchPaths.forEach(function (sp) {\n    var searchString = path.join(sp, dirname, basename + '.*' + extname);\n    var prefixSearchString = path.join(sp, dirname, '*.' + basename + extname);\n\n    if (searchString.indexOf('#') === 0) {\n      // patterns starting with # are treated as comments by the glob implementation which returns undefined,\n      // which would cause an unhandled exception in self.expandfn below so the file is never written\n      return;\n    }\n\n    debug('Looking for %s and %s on disk', searchString, prefixSearchString);\n\n    var files = self.expandfn([searchString, prefixSearchString]);\n\n    debug('Found ', files);\n\n    // Keep only files that look like a revved file\n    var goodFiles = files.filter(function (f) {\n      return f.match(revvedRx);\n    });\n\n    // We must now remove the search path from the beginning, and add them to the\n    // list of candidates\n    goodFiles.forEach(function (gf) {\n      var goodFileName = path.basename(gf);\n      if (!file.match(/\\//)) {\n        // We only get a file (i.e. no dirs), so let's send back\n        // what we found\n        debug('Adding %s to candidates', goodFileName);\n        candidates.push(goodFileName);\n      } else {\n        debug('Adding %s / %s to candidates', dirname, goodFileName);\n        candidates.push(dirname + '/' + goodFileName);\n      }\n    });\n  });\n\n  return candidates;\n};\n\n\n// Finds out candidates for file in the furnished searchPaths.\n// It should return an array of candidates that are in the same format as the\n// furnished file.\n// For example, when given file 'images/test.png', and searchPaths of ['dist']\n// the returned array should be something like ['images/test.1234.png']\n//\nRevvedFinder.prototype.getRevvedCandidates = function (file, searchPaths) {\n  var candidates;\n\n  // Our strategy depends on what we get at creation time: either a mapping, and we \"just\"\n  // need to do look-up in the mapping, or an expand function and we need to find relevant files\n  // on the disk\n  // FIXME:\n\n  if (this.mapping) {\n    debug('Looking at mapping');\n    candidates = this.getCandidatesFromMapping(file, searchPaths);\n  } else {\n    debug('Looking on disk');\n    candidates = this.getCandidatesFromFS(file, searchPaths);\n  }\n\n  return candidates;\n};\n\n//\n// Find a revved version of +ofile+ (i.e. a file which name is ending with +ofile+), relatively\n// to the furnished +searchDirs+.\n// Let's imagine you have the following directory structure:\n//  + build\n//  |  |\n//  |  +- css\n//  |      |\n//  |      + style.css\n//  + images\n//     |\n//     + pic.2123.png\n//\n// and that somehow style.css is referencing '../../images/pic.png'\n// When called like that:\n//   revvedFinder.find('../../images/pic.png', 'build/css');\n// the function must return\n// '../../images/pic.2123.png'\n//\n// Note that +ofile+ should be a relative path to the looked for file\n// (i.e. if it's an absolute path -- starting with / -- or an external one -- containing :// -- then\n//  the original file is returned)\n//\n// It returns an object with 2 attributes:\n//  name: which is the filename\n//  base: which is the directory from searchDirs where we found the file\n//\nRevvedFinder.prototype.find = function find(ofile, searchDirs) {\n  var file = ofile;\n  var searchPaths = searchDirs;\n  var absolute;\n  var prefix;\n\n  if (_.isString(searchDirs)) {\n    searchPaths = [searchDirs];\n  }\n\n  debug('Looking for revved version of %s in ', ofile, searchPaths);\n\n  // do not touch external files or the root\n  // FIXME: Should get only relative files\n  if (ofile.match(/:\\/\\//) || ofile === '') {\n    return ofile;\n  }\n\n  if (file[0] === '/') {\n    // We need to remember this is an absolute file, but transform it\n    // to a relative one\n    absolute = true;\n    file = file.replace(/^(\\/+)/, function (match, header) {\n      prefix = header;\n      return '';\n    });\n  }\n\n  var filepaths = this.getRevvedCandidates(file, searchPaths);\n\n  var filepath = filepaths[0];\n  debug('filepath is now ', filepath);\n\n  // not a file in temp, skip it\n  if (!filepath) {\n    return ofile;\n  }\n\n  // var filename = path.basename(filepath);\n  // handle the relative prefix (with always unix like path even on win32)\n  // if (dirname !== '.') {\n  //   filename = [dirname, filename].join('/');\n  // }\n\n  if (absolute) {\n    filepath = prefix + filepath;\n  }\n\n  debug('Let\\'s return %s', filepath);\n  return filepath;\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-usemin/node_modules/grunt-usemin/tasks/usemin.js":"'use strict';\nvar util = require('util');\nvar chalk = require('chalk');\n\n// Retrieve the flow config from the furnished configuration. It can be:\n//  - a dedicated one for the furnished target\n//  - a general one\n//  - the default one\nvar getFlowFromConfig = function (config, target) {\n  var Flow = require('../lib/flow');\n  var flow = new Flow({\n    steps: {\n      js: ['concat', 'uglify'],\n      css: ['concat', 'cssmin']\n    },\n    post: {}\n  });\n  if (config.options && config.options.flow) {\n    if (config.options.flow[target]) {\n      flow.setSteps(config.options.flow[target].steps);\n      flow.setPost(config.options.flow[target].post);\n    } else {\n      flow.setSteps(config.options.flow.steps);\n      flow.setPost(config.options.flow.post);\n    }\n  }\n  return flow;\n};\n\n//\n// Return which locator to use to get the revisioned version (revved) of the files, with, by order of\n// preference:\n// - a map object passed in option (revmap)\n// - a map object produced by grunt-filerev if available\n// - a disk lookup\n//\nvar getLocator = function (grunt, options) {\n  var locator;\n  if (options.revmap) {\n    locator = grunt.file.readJSON(options.revmap);\n  } else if (grunt.filerev && grunt.filerev.summary) {\n    locator = grunt.filerev.summary;\n  } else {\n    locator = function (p) {\n      return grunt.file.expand({\n        filter: 'isFile'\n      }, p);\n    };\n  }\n  return locator;\n};\n\n//\n// ### Usemin\n\n// Replaces references to non-optimized scripts or stylesheets\n// into a set of HTML files (or any templates/views).\n//\n// The users markup should be considered the primary source of information\n// for paths, references to assets which should be optimized.We also check\n// against files present in the relevant directory () (e.g checking against\n// the revved filename into the 'temp/') directory to find the SHA\n// that was generated.\n//\n// Todos:\n// * Use a file dictionary during build process and rev task to\n// store each optimized assets and their associated sha1.\n//\n// #### Usemin-handler\n//\n// A special task which uses the build block HTML comments in markup to\n// get back the list of files to handle, and initialize the grunt configuration\n// appropriately, and automatically.\n//\n// Custom HTML \"block\" comments are provided as an API for interacting with the\n// build script. These comments adhere to the following pattern:\n//\n//     <!-- build:<type> <path> -->\n//       ... HTML Markup, list of script / link tags.\n//     <!-- endbuild -->\n//\n// - type: is either js or css.\n// - path: is the file path of the optimized file, the target output.\n//\n// An example of this in completed form can be seen below:\n//\n//    <!-- build:js js/app.js -->\n//      <script src=\"js/app.js\"></script>\n//      <script src=\"js/controllers/thing-controller.js\"></script>\n//      <script src=\"js/models/thing-model.js\"></script>\n//      <script src=\"js/views/thing-view.js\"></script>\n//    <!-- endbuild -->\n//\n//\n// Internally, the task parses your HTML markup to find each of these blocks, and\n// initializes for you the corresponding Grunt config for the concat / uglify tasks\n// when `type=js`, the concat / cssmin tasks when `type=css`.\n//\n\nmodule.exports = function (grunt) {\n  var FileProcessor = require('../lib/fileprocessor');\n  var RevvedFinder = require('../lib/revvedfinder');\n  var ConfigWriter = require('../lib/configwriter');\n  var _ = require('lodash');\n\n  grunt.registerMultiTask('usemin', 'Replaces references to non-minified scripts / stylesheets', function () {\n    var debug = require('debug')('usemin:usemin');\n    var options = this.options({\n      type: this.target\n    });\n    var blockReplacements = options.blockReplacements || {};\n\n    debug('Looking at %s target', this.target);\n    var patterns = [];\n    var type = this.target;\n\n    // Check if we have a user defined pattern\n    if (options.patterns && options.patterns[this.target]) {\n      debug('Adding user defined patterns for %s', this.target);\n      patterns = options.patterns[this.target];\n    }\n\n    // var locator = options.revmap ? grunt.file.readJSON(options.revmap) : function (p) { return grunt.file.expand({filter: 'isFile'}, p); };\n    var locator = getLocator(grunt, options);\n    var revvedfinder = new RevvedFinder(locator);\n    var handler = new FileProcessor(type, patterns, revvedfinder, function (msg) {\n      grunt.verbose.writeln(msg);\n    }, blockReplacements);\n\n    this.files.forEach(function (fileObj) {\n      var files = grunt.file.expand({\n        nonull: true,\n        filter: 'isFile'\n      }, fileObj.src);\n      files.forEach(function (filename) {\n        debug('looking at file %s', filename);\n\n        grunt.verbose.writeln(chalk.bold('Processing as ' + options.type.toUpperCase() + ' - ') + chalk.cyan(filename));\n\n        // Our revved version locator\n        var content = handler.process(filename, options.assetsDirs);\n\n        // write the new content to disk\n        grunt.file.write(filename, content);\n\n      });\n\n      grunt.log.writeln('Replaced ' + chalk.cyan(files.length) + ' ' +\n        (files.length === 1 ? 'reference' : 'references') + ' to assets'\n      );\n    });\n  });\n\n  grunt.registerMultiTask('useminPrepare', 'Using HTML markup as the primary source of information', function () {\n    var options = this.options();\n    // collect files\n    var dest = options.dest || 'dist';\n    var staging = options.staging || '.tmp';\n    var root = options.root;\n\n    grunt.verbose\n      .writeln('Going through ' + grunt.log.wordlist(this.filesSrc) + ' to update the config')\n      .writeln('Looking for build script HTML comment blocks');\n\n    var flow = getFlowFromConfig(grunt.config('useminPrepare'), this.target);\n\n    var c = new ConfigWriter(flow, {\n      root: root,\n      dest: dest,\n      staging: staging\n    });\n\n    var cfgNames = [];\n    c.stepWriters().forEach(function (i) {\n      cfgNames.push(i.name);\n    });\n    c.postWriters().forEach(function (i) {\n      cfgNames.push(i.name);\n    });\n    var gruntConfig = {};\n    _.forEach(cfgNames, function (name) {\n      gruntConfig[name] = grunt.config(name) || {};\n    });\n\n    this.filesSrc.forEach(function (filepath) {\n      var config;\n      try {\n        config = c.process(filepath, grunt.config());\n      } catch (e) {\n        grunt.fail.warn(e);\n      }\n\n      _.forEach(cfgNames, function (name) {\n        gruntConfig[name] = grunt.config(name) || {};\n        grunt.config(name, _.assign(gruntConfig[name], config[name]));\n      });\n\n    });\n\n    // log a bit what was added to config\n    grunt.verbose.subhead('Configuration is now:');\n    _.forEach(cfgNames, function (name) {\n      grunt.verbose.subhead('  ' + name + ':')\n        .writeln('  ' + util.inspect(grunt.config(name), false, 4, true, true));\n    });\n\n    // only displayed if not in verbose mode\n    grunt.verbose.or.writeln('Configuration changed for', grunt.log.wordlist(cfgNames));\n  });\n};\n"}